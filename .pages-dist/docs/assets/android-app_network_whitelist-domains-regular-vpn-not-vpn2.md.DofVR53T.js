import{_ as i,c as o,o as a,ae as t}from"./chunks/framework.Cqi9LMMK.js";const u=JSON.parse('{"title":"Whitelist domains (regular VPN, not VPN2)","description":"","frontmatter":{},"headers":[],"relativePath":"android-app/network/whitelist-domains-regular-vpn-not-vpn2.md","filePath":"android-app/network/whitelist-domains-regular-vpn-not-vpn2.md"}'),l={name:"android-app/network/whitelist-domains-regular-vpn-not-vpn2.md"};function d(s,e,n,r,c,h){return a(),o("div",null,[...e[0]||(e[0]=[t('<h1 id="whitelist-domains-regular-vpn-not-vpn2" tabindex="-1">Whitelist domains (regular VPN, not VPN2) <a class="header-anchor" href="#whitelist-domains-regular-vpn-not-vpn2" aria-label="Permalink to &quot;Whitelist domains (regular VPN, not VPN2)&quot;">​</a></h1><h2 id="where-it-lives" tabindex="-1">Where it lives <a class="header-anchor" href="#where-it-lives" aria-label="Permalink to &quot;Where it lives&quot;">​</a></h2><ul><li><code>app/src/main/java/com/tripleu/ui/fragments/PrivacyFragment.kt</code></li><li><code>app/src/main/java/com/tripleu/ui/fragments/PrivacyDialogState.kt</code></li><li><code>app/src/main/java/com/tripleu/ui/components/HostWhitelistDialogUi.kt</code></li><li><code>app/src/main/java/com/tripleu/vpn/WhitelistVpnService.kt</code></li><li><code>app/src/main/java/com/tripleu/vpn/AdVpnThread.java</code></li><li><code>app/src/main/java/com/tripleu/vpn/Configuration.java</code></li><li><code>app/src/main/java/com/tripleu/dp/RuleDatabase.java</code></li><li><code>app/src/main/java/com/tripleu/vpn/DnsPacketProxy.java</code></li><li><code>app/src/main/java/com/tripleu/config/ConfigPoller.kt</code></li></ul><h2 id="what-it-does" tabindex="-1">What it does <a class="header-anchor" href="#what-it-does" aria-label="Permalink to &quot;What it does&quot;">​</a></h2><ul><li>Enables the domain whitelist mode using <code>WhitelistVpnService</code> (extends <code>AdVpnService</code>).</li><li>Uses <code>Configuration.hosts</code> as the active host list.</li><li>Disables Private DNS and the main VPN toggle while whitelist mode is active.</li><li>DNS-level filtering only (no TLS decrypt).</li></ul><h2 id="how-domain-filtering-works" tabindex="-1">How domain filtering works <a class="header-anchor" href="#how-domain-filtering-works" aria-label="Permalink to &quot;How domain filtering works&quot;">​</a></h2><ul><li><code>RuleDatabase.initialize(...)</code> loads allowed hosts when <code>config.hosts.enabled=true</code>.</li><li><code>DnsPacketProxy</code> checks <code>RuleDatabase.isAllowed(host)</code> for each DNS query: <ul><li>Allowed domains are forwarded to upstream DNS.</li><li>Not allowed domains are answered with a negative response.</li></ul></li><li>Subdomains are allowed when the parent domain is in the list.</li><li>Each <code>Configuration.Item</code> can be a single host or a file/URL; <code>RuleDatabase</code> parses hosts files when present.</li></ul><h2 id="import-and-edit" tabindex="-1">Import and edit <a class="header-anchor" href="#import-and-edit" aria-label="Permalink to &quot;Import and edit&quot;">​</a></h2><ul><li>The whitelist UI is <code>HostWhitelistDialogCard</code>.</li><li>Manual input and file import both use <code>parseDomains(...)</code>: <ul><li>Strips scheme/path/ports and <code>*.</code> wildcards.</li><li>Splits on commas, semicolons, and whitespace.</li><li>Deduplicates entries.</li></ul></li><li>File import uses the system picker (<code>OpenDocument</code>) and reads raw text.</li><li>On save, entries are stored as <code>Configuration.Item</code> with <code>state=ALLOW</code>.</li></ul><h2 id="how-it-runs" tabindex="-1">How it runs <a class="header-anchor" href="#how-it-runs" aria-label="Permalink to &quot;How it runs&quot;">​</a></h2><ul><li>Toggle on opens <code>HostWhitelistDialogCard</code> to add or import domains. <ul><li>Input is normalized by <code>parseDomains</code> (strips scheme/path/ports and wildcards).</li><li>Required Firebase hosts are auto-added in <code>ensureRequiredWhitelistHosts(...)</code>.</li></ul></li><li>On save, <code>applyWhitelistSelection(...)</code>: <ul><li>Writes hosts to config via <code>FileHelper</code> and to <code>ConfigStore</code> (<code>network.domain_whitelist_hosts</code>).</li><li>Sets <code>network.domain_whitelist_enabled=true</code>.</li><li>Stops <code>AdVpnService</code> if running and forces Private DNS off.</li><li>Starts <code>WhitelistVpnService</code> after VPN consent (<code>REQUEST_START_WHITELIST</code>).</li><li>Calls <code>RuleDatabaseUpdateTask</code> to refresh host rules.</li></ul></li><li>Toggle off runs <code>disableWhitelistMode()</code>: <ul><li>Sets <code>hosts.enabled=false</code>, stops <code>WhitelistVpnService</code>, re-enables VPN/Private DNS toggles.</li><li>Writes <code>network.domain_whitelist_enabled=false</code> and clears <code>network.domain_whitelist_hosts</code>.</li></ul></li><li><code>AdVpnThread</code> treats <code>hosts.enabled</code> as whitelist mode and routes all apps through the VPN so DNS filtering applies.</li><li>Cloud config <code>network.domain_whitelist_enabled</code> + <code>network.domain_whitelist_hosts</code> are applied in <code>ConfigPoller</code> (skipped if <code>Vpn2State.shouldBlockLegacy(...)</code> is true).</li><li>Entering whitelist mode clears <code>firewall_rules</code> so per-app network rules do not conflict.</li></ul><h2 id="on-boot" tabindex="-1">On boot <a class="header-anchor" href="#on-boot" aria-label="Permalink to &quot;On boot&quot;">​</a></h2><ul><li><code>BootComplete</code> calls <code>AdVpnService.checkStartVpnOnBoot(...)</code>.</li><li>If <code>config.autoStart</code> is true and <code>hosts.enabled=true</code>, it starts <code>WhitelistVpnService</code>.</li><li>Legacy VPN is skipped if <code>Vpn2State.shouldBlockLegacy(...)</code> is true.</li></ul>',13)])])}const m=i(l,[["render",d]]);export{u as __pageData,m as default};
